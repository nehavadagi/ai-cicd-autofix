const core = require('@actions/core');
const github = require('@actions/github');
const { parseLogForError } = require('./log-parser');
const { applyDiff } = require('./diff-applier');
const axios = require('axios');

async function run() {
  try {
    // Get inputs
    const token = core.getInput('github-token');
    const modelApiUrl = core.getInput('model-api-url');
    const confidenceThreshold = parseFloat(core.getInput('confidence-threshold') || '0.7');
    
    const octokit = github.getOctokit(token);
    const context = github.context;

    // Check if the triggering workflow run failed
    if (context.payload.workflow_run.conclusion !== 'failure') {
      core.info('The triggering workflow did not fail. Exiting.');
      return;
    }

    const owner = context.repo.owner;
    const repo = context.repo.repo;
    const runId = context.payload.workflow_run.id;
    const head_sha = context.payload.workflow_run.head_sha;
    const head_branch = context.payload.workflow_run.head_branch;

    core.info(`Attempting to fix failed workflow run #${runId} for commit ${head_sha}`);

    // 1. Get the logs for the failed run
    core.info('Fetching workflow logs...');
    const logsResponse = await octokit.rest.actions.downloadWorkflowRunLogs({
      owner,
      repo,
      run_id: runId,
    });

    const logData = Buffer.from(logsResponse.data).toString('utf8');
    core.debug(`Raw logs: ${logData.substring(0, 1000)}...`);

    // 2. Parse the log to find the Java compilation error
    core.info('Parsing logs for Java compilation errors...');
    const errorInfo = parseLogForError(logData);
    
    if (!errorInfo) {
      core.info('No recognizable Java compilation error found in logs.');
      return;
    }

    core.info(`Identified error: ${errorInfo.message} in file ${errorInfo.filePath}`);

    // 3. Get the content of the broken file at the failing commit
    core.info(`Fetching file content for ${errorInfo.filePath}...`);
    const fileResponse = await octokit.rest.repos.getContent({
      owner,
      repo,
      path: errorInfo.filePath,
      ref: head_sha,
    });

    const fileContent = Buffer.from(fileResponse.data.content, 'base64').toString('utf8');
    const fileSha = fileResponse.data.sha;

    // 4. Call the AI Model API
    core.info('Calling AI model for fix generation...');
    const requestBody = {
      error_message: errorInfo.message,
      context_code: fileContent,
      file_path: errorInfo.filePath
    };

    const apiResponse = await axios.post(`${modelApiUrl}/predict`, requestBody, {
      headers: { 'Content-Type': 'application/json' },
      timeout: 30000
    });

    const { generated_diff, confidence } = apiResponse.data;
    core.info(`Model generated a fix with confidence: ${confidence}`);

    // 5. Check confidence threshold and take appropriate action
    if (confidence < confidenceThreshold) {
      core.info(`Confidence ${confidence} below threshold ${confidenceThreshold}. Creating an issue.`);
      
      await octokit.rest.issues.create({
        owner,
        repo,
        title: `ðŸ¤– AI Analysis for failed build on ${head_sha.substring(0, 7)}`,
        body: `## Build Failure Analysis\n**Error:** ${errorInfo.message}\n**File:** ${errorInfo.filePath}\n\n## Suggested Fix\n\`\`\`diff\n${generated_diff}\n\`\`\`\n\n*Confidence: ${confidence} (below ${confidenceThreshold} threshold)*\n*This was generated automatically. Please review and apply manually.*`
      });
      
      return;
    }

    // 6. HIGH CONFIDENCE: Create a branch, apply the fix, and open a PR
    core.info('Confidence threshold met. Creating fix...');
    
    const newBranchName = `ai-fix/build-failure-${runId}`;
    const prTitle = `ðŸ¤– AI Fix: ${errorInfo.message.substring(0, 100)}`;
    const prBody = `This Pull Request was automatically generated by the AI Build Fixer Action to resolve the build failure in commit ${head_sha}.\n\n**Error:** ${errorInfo.message}\n**File:** ${errorInfo.filePath}\n**Confidence:** ${confidence}\n\n## Changes:\n\`\`\`diff\n${generated_diff}\n\`\`\`\n\n---\n*Automatically generated by [AI Build Fixer](https://github.com/your-username/ai-cicd-autofix)*`;

    // Create a new branch
    core.info(`Creating branch: ${newBranchName}`);
    await octokit.rest.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${newBranchName}`,
      sha: head_sha
    });

    // Apply the diff
    const fixedContent = applyDiff(fileContent, generated_diff);
    
    // Commit the fixed file
    core.info(`Committing fix to ${errorInfo.filePath}`);
    await octokit.rest.repos.createOrUpdateFileContents({
      owner,
      repo,
      path: errorInfo.filePath,
      message: `fix: AI-generated patch for ${errorInfo.message.substring(0, 50)}`,
      content: Buffer.from(fixedContent).toString('base64'),
      branch: newBranchName,
      sha: fileSha
    });

    // Create a Pull Request
    core.info('Creating Pull Request...');
    const prResponse = await octokit.rest.pulls.create({
      owner,
      repo,
      title: prTitle,
      head: newBranchName,
      base: head_branch,
      body: prBody
    });

    core.info(`Successfully created Pull Request: ${prResponse.data.html_url}`);

    // Add a comment to the PR with additional context
    await octokit.rest.issues.createComment({
      owner,
      repo,
      issue_number: prResponse.data.number,
      body: `ðŸ”§ This fix was automatically generated with **${(confidence * 100).toFixed(1)}% confidence**.\n\nThe AI model analyzed the build error and generated this patch. Please review the changes before merging.`
    });

  } catch (error) {
    core.error(`Action failed: ${error.message}`);
    core.setFailed(`Action failed with error: ${error.message}`);
  }
}

run();